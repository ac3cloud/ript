{"body":"Ript\r\n====\r\n\r\nRipt provides a clean Ruby DSL for describing firewall rules, and implements\r\ndatabase migrations-like functionality for applying the rules with zero downtime.\r\n\r\nRipt works with `iptables` on Linux, and is written in Ruby.\r\n\r\nInstalling\r\n----------\r\n\r\nMake sure you have Ruby 1.9.2 installed, and run:\r\n\r\n``` bash\r\ngem install ript\r\n```\r\n\r\nIf you want the firewall rules to be reloaded at reboot, you will need to set up an\r\ninit script.\r\n\r\n``` bash\r\nsudo cp \"$(dirname $(dirname $(dirname $(gem which ript/dsl.rb))))\"/dist/init.d /etc/init.d/ript\r\nsudo update-rc.d ript defaults\r\nsudo mkdir /var/lib/ript\r\nsudo chown root.adm /var/lib/ript\r\nsudo chmod 770 /var/lib/ript\r\n```\r\n\r\nApplying rules\r\n--------------\r\n\r\n - Run `ript rules generate <path>` - will output all the generated rules by interpreting the file, or files in directory, `<path>`\r\n - Run `ript rules diff <path>` - will output a diff of rules to apply based on what rules are currently loaded in memory\r\n - Run `ript rules apply <path>` - will apply the aforementioned diff\r\n - Run `ript rules diff <path>` - will display any rules not applied correctly\r\n - Run `ript rules save` - will output the currently loaded rule in iptables-restore format\r\n - Run `ript clean diff <path>` - will output iptables commands to delete unneeded rules\r\n - Run `ript clean apply <path>` - will run the iptables commands to delete unneeded rules\r\n\r\nThere are tests for this workflow in `features/cli.feature`\r\n\r\nNote: If you are using the supplied init script then you will need to add:\r\n``` bash\r\nript rules save > /var/lib/ript/iptables.stat\r\n```\r\nto your workflow.\r\n\r\nDeveloping\r\n----------\r\n\r\nIt is recommended to use a Ubuntu Lucid VM to develop Ript. If you develop on a machine without iptables some of the tests will fail.\r\n\r\nIt is also recommended that you use [rbenv](http://rbenv.org/).\r\n\r\n``` bash\r\nrbenv install 1.9.2-p290\r\ngem install bundler\r\nrbenv rehash\r\n```\r\n\r\nThen to setup a Ript development environment, run:\r\n\r\n``` bash\r\ngit clone git@github.com:bulletproofnetworks/ript.git\r\ncd ript\r\nbundle\r\nrbenv rehash\r\n```\r\n\r\nThen run the tests with:\r\n\r\n``` bash\r\n# Run all the tests\r\nsudo bin/rbenv-sudo rake features\r\n# Run a specific test file\r\nsudo bin/rbenv-sudo cucumber -r features/support/ -r features/step_definitions/ features/dsl/filter.feature\r\n# Run a specific test in a file\r\nsudo bin/rbenv-sudo cucumber -r features/support/ -r features/step_definitions/ features/dsl/filter.feature:13\r\n```\r\n\r\nript commands can be run like so:\r\n\r\n```` bash\r\nsudo bin/rbenv-sudo bundle exec ript --help\r\n```\r\n\r\nReleasing\r\n---------\r\n\r\n1. Bump the version in `lib/ript/version.rb`\r\n2. Add an entry to `CHANGELOG.md`\r\n3. Run a `bundle` to update any RubyGems dependencies.\r\n4. `git commit` everything.\r\n5. git tag the version git tag X.Y.Z\r\n6. Build the gem with `rake build`\r\n\r\nThis will build a `.gem` and a `.deb` in `pkg/`\r\n\r\nDesign\r\n------\r\n\r\n - Applying firewall rules should cause zero downtime.\r\n - Making a change to a partition's rules should only ever affect that partition.\r\n - Each partition has their own set of chains where their rules live.\r\n - Each chain is self contained, and there a pointers to that chain from a\r\n   global chain where all partition pointers live.\r\n - The pointer rules should be kept very simple, to reduce the chain traversal\r\n   time for packets.\r\n - Rolling forward is as simple as creating a new chain, and inserting pointers\r\n   to the new chain in the global chain.\r\n - Rolling back is as simple as deleting the pointers to the new chain from the\r\n   global chain. The new chain could be retained, but we choose delete it.\r\n - Decommissioning a partition should be as simple as removing the partition's\r\n   rules file.\r\n - Deleting the rules file will cause Ript to realise the partition's chains\r\n   should be deleted.\r\n\r\nThe DSL\r\n-------\r\n\r\nThe core of Ript is its easy to use DSL to describe iptables firewall rules.\r\n\r\nThe DSL is flexible and handles both simple and complex use cases.\r\n\r\n### Introduction ###\r\n\r\n![Book cover - http://www.flickr.com/photos/sterlic/4299631538/sizes/z/in/photostream/](http://farm5.staticflickr.com/4116/4880818306_3bd230d0d4_z.jpg)\r\n\r\nLet's start from the beginning:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  # Labels + rules go here\r\nend\r\n```\r\n\r\nAll labels + rules in Ript are wrapped in a `partition` block, which partitions\r\npartition rules so they can be changed on a per-partition basis. This is integral\r\nto how Ript does zero-downtime rule migrations.\r\n\r\nSo, what are labels?\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\nend\r\n```\r\n\r\nLabels are identifiers for addresses or subnets that you want to write rules\r\nfor.\r\n\r\nWhat are rules?\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n\r\n  rewrite \"public website\" do\r\n    ports 80\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\nend\r\n```\r\n\r\nRules define how traffic flows from one place to another. Rules can either\r\nrewrite the source or destination of a packet (SNAT and DNAT), or permit/deny\r\nthe flow of traffic:\r\n\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"trusted office\",     :address => \"172.20.4.124\"\r\n\r\n  rewrite \"public website\" do\r\n    ports 80\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  rewrite \"public ssh access\" do\r\n    ports 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nIn the above example, we are telling Ript we want SSH traffic to\r\n`www.joeblogsco.co` (`172.19.56.216`) which is on a public network to be sent\r\nto `app-01` (`192.168.5.230`), which is on a private network.\r\n\r\nBecause the default policy is to drop packets that don't have an explicit\r\nmatch, we also need an `accept` rule so that the traffic being rewritten is also\r\nallowed to pass through.\r\n\r\nRipt knows this is generally what you want to do, so it actually creates this\r\nrule for you automatically. If we were to write it out, it would look something\r\nlike this:\r\n\r\n``` ruby\r\nrewrite \"public ssh access\" do\r\n  ports 22\r\n  dnat  \"www.joeblogsco.com\" => \"app-01\"\r\nend\r\n\r\naccept \"allow public ssh access\" do\r\n  protocols \"tcp\"\r\n  ports     22\r\n  to        \"www.joeblogsco.com\"\r\nend\r\n```\r\n\r\nRipt's DSL is actually pretty smart, so we can clean up the above example a\r\nbit:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"trusted office\",     :address => \"172.20.4.124\"\r\n\r\n  rewrite \"public website + ssh access\" do\r\n    ports 80, 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nHere we have collapsed the two rewrite rules into one. Ript does the heavy\r\nlifting behind the scenes to generate the all the rules.\r\n\r\nIf you want to be more specific about your rewrites (for example, you only want\r\nexternal SSH access from a specific jump host), it's really straight forward:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"trusted office\",     :address => \"172.20.4.124\"\r\n\r\n  rewrite \"public website\" do\r\n    ports 80\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  rewrite \"trusted ssh access\" do\r\n    ports 22\r\n    from \"trusted office\"\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\nend\r\n```\r\n\r\n<a id=\"ports\"></a>\r\nYou have a lot of flexibility when specifying ports, port ranges, and port mappings:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"api.joeblogsco.com\", :address => \"172.19.56.217\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"app-02\",             :address => \"192.168.5.231\"\r\n  label \"trusted office\",     :address => \"172.20.4.124\"\r\n\r\n  rewrite \"public mail\" do\r\n    # Pass TCP port 25 + 993 through to app-01\r\n    ports 25, 993\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  rewrite \"trusted private services\" do\r\n    # Pass TCP port 6000 to 8000 through to app-01 from the trusted office\r\n    from \"trusted office\"\r\n    ports 6000..8000\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  rewrite \"public website\" do\r\n    # Map TCP port 80 traffic on the public IP to TCP port 8080 on app-01\r\n    ports 80 => 8080\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  rewrite \"api services\" do\r\n    # Pass TCP port 80 through to app-02\r\n    # Pass TCP port 8000 to 8900 through to app-02\r\n    # Map TCP port 2222 traffic on the public IP to TCP port 22 on app-02\r\n    ports 80, 8000..8900, 2222 => 22\r\n    dnat  \"api.joeblogsco.com\" => \"app-02\"\r\n  end\r\nend\r\n```\r\n\r\nThe above `ports` syntax works throughout all rule types.\r\n\r\nSome notes on the DSL so far:\r\n\r\n - A label's scope is restricted to the partition block it is defined in. This\r\n   means you can use the same labels across different partitions and there won't\r\n   be naming colissions.\r\n\r\n - The string argument passed to `rewrite`, `accept`, and other DSL rules is\r\n   used purely for documentation (think comments). Other people maintaining your\r\n   firewall rules will love you when you describe the intention of those rule in\r\n   these comments.\r\n\r\n   It's always best to write rules as if the person who ends up maintaining your\r\n   rules is a violent psychopath who knows where you live.\r\n\r\n - Rules will default to the TCP protocol if you don't specify one. Valid\r\n   protocols can be found in `/etc/protocols` on any Linux system. Ript accepts\r\n   both the numeric and string identifiers (`udp` and `17` are both valid), but\r\n   strongly recommends you use the string identifiers.\r\n\r\n - Given `accept` rules are created automatically when you define a rewrite, you\r\n   may be wondering if `accept` rules are used at all?\r\n\r\n   `accept` is very useful on standalone firewalls, when opening up specific\r\n   ports to the public internet.\r\n\r\n   For firewall configurations that are doing lots of public-to-private address\r\n   translation, you're going to use `accepts` very rarely.\r\n\r\n - Arguments to `ports` can be mixed (`ports 500..650, 80, 25, 9000..9500`),\r\n   but you must always specify port mappings last, e.g. `ports 25, 80 => 8080`\r\n   is valid, but `ports 80 => 8080, 25` is not.\r\n\r\n\r\n### Rule types ###\r\n\r\n![Ruler - http://www.flickr.com/photos/sterlic/4299631538/](http://farm3.staticflickr.com/2730/4299631538_220c9c9448_z.jpg)\r\n\r\nThe introduction examples cover the common use cases, but Ript has support for\r\nmany other types of rules.\r\n\r\nFor example, SNAT:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"joeblogsco subnet\",  :address => \"192.168.5.224/27\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n\r\n  rewrite \"private to public\" do\r\n    snat \"joeblogsco subnet\" => \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nThe above SNAT rule will rewrite all outgoing traffic from the\r\n`joeblogsco subnet` to appear as if it's originating from `www.joeblogsco.com`\r\n(`172.19.56.216`).\r\n\r\nIf you need to explicitly drop traffic from somewhere, Ript makes this trivial:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"bad guy\",            :address => \"172.19.110.247\"\r\n\r\n  rewrite \"public website + ssh access\" do\r\n    ports 80, 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  drop \"bad guy\" do\r\n    from \"bad guy\"\r\n    to   \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nYou can also broaden your drop to subnets, and restrict it down to a protocol:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"bad guys\",           :address => \"10.0.0.0/8\"\r\n\r\n  rewrite \"public website + ssh access\" do\r\n    ports 80, 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  drop \"bad guys\" do\r\n    protocols \"udp\"\r\n    from      \"bad guys\"\r\n    to        \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nAlternatively, you can also reject the traffic:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"bad guys\",           :address => \"10.0.0.0/8\"\r\n\r\n  rewrite \"public website + ssh access\" do\r\n    ports 80, 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  reject \"bad guys\" do\r\n    protocols \"udp\"\r\n    from      \"bad guys\"\r\n    to        \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\n### Logging ###\r\n\r\n![Logs - http://www.flickr.com/photos/crawshawt/4636162605/](http://farm5.staticflickr.com/4020/4636162605_9ac8e91b56_z.jpg)\r\n\r\nDropping and rejecting traffic is very useful, but if a tree falls in the\r\nforest and no-one is there to hear it...\r\n\r\nRipt makes flipping on logging extremely simple:\r\n\r\n``` ruby\r\n# partitions/joeblogsco.rb\r\npartition \"joeblogsco\" do\r\n  label \"www.joeblogsco.com\", :address => \"172.19.56.216\"\r\n  label \"app-01\",             :address => \"192.168.5.230\"\r\n  label \"bad guys\",           :address => \"10.0.0.0/8\"\r\n\r\n  rewrite \"public website + ssh access\", :log => true do\r\n    ports 80, 22\r\n    dnat  \"www.joeblogsco.com\" => \"app-01\"\r\n  end\r\n\r\n  reject \"bad guys\", :log => true do\r\n    protocols \"udp\"\r\n    from      \"bad guys\"\r\n    to        \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nYou can pass `:log => true` to any rule, and Ript will automatically generate\r\nlogging statements.\r\n\r\n\r\n### Shortcuts ###\r\n\r\n![Shorthand http://www.flickr.com/photos/sizemore/2215594186/](http://farm3.staticflickr.com/2397/2215594186_c979f71689_z.jpg)\r\n\r\nRipt provides shortcuts for setting up common rules:\r\n\r\n``` ruby\r\npartition \"joeblogsco\" do\r\n  label \"joeblogsco uat subnet\",   :address => \"192.168.5.0/24\"\r\n  label \"joeblogsco stage subnet\", :address => \"10.60.2.0/24\"\r\n  label \"joeblogsco prod subnet\",  :address => \"10.60.3.0/24\"\r\n  label \"www.joeblogsco.com\",      :address => \"172.19.56.216\"\r\n\r\n  rewrite \"private to public\" do\r\n    snat  [ \"joeblogsco uat subnet\",\r\n            \"joeblogsco stage subnet\",\r\n            \"joeblogsco prod subnet\"  ] => \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nRipt will expand the above to:\r\n\r\n``` ruby\r\npartition \"joeblogsco\" do\r\n  label \"joeblogsco uat subnet\",   :address => \"192.168.5.0/24\"\r\n  label \"joeblogsco stage subnet\", :address => \"10.60.2.0/24\"\r\n  label \"joeblogsco prod subnet\",  :address => \"10.60.3.0/24\"\r\n  label \"www.joeblogsco.com\",      :address => \"172.19.56.216\"\r\n\r\n  rewrite \"private to public\" do\r\n    snat \"joeblogsco uat subnet\" => \"www.joeblogsco.com\"\r\n  end\r\n\r\n  rewrite \"private to public\" do\r\n    snat \"joeblogsco stage subnet\" => \"www.joeblogsco.com\"\r\n  end\r\n\r\n  rewrite \"private to public\" do\r\n    snat \"joeblogsco prod subnet\" => \"www.joeblogsco.com\"\r\n  end\r\nend\r\n```\r\n\r\nThis also behaves exactly the same way with `accept`/`reject`/`drop` rules:\r\n\r\n``` ruby\r\npartition \"tootyfruity\" do\r\n  label \"apple\",      :address => \"192.168.0.1\"\r\n  label \"blueberry\",  :address => \"192.168.0.2\"\r\n  label \"cranberry\",  :address => \"192.168.0.3\"\r\n  label \"eggplant\",   :address => \"192.168.0.4\"\r\n  label \"fennel\",     :address => \"192.168.0.5\"\r\n  label \"grapefruit\", :address => \"192.168.0.6\"\r\n\r\n  accept \"fruits of the forest\" do\r\n    protocols \"tcp\"\r\n    ports     22\r\n    from      %w(apple blueberry cranberry eggplant fennel grapefruit)\r\n    to        %w(apple blueberry cranberry eggplant fennel grapefruit)\r\n  end\r\nend\r\n```\r\n\r\nIn the above example, Ript will generate rules for all the different\r\ncombinations of `from` + `to` hosts.\r\n\r\nYou can also specify ranges of ports to generate rules for, and setup port\r\nmappings:\r\n\r\n``` ruby\r\npartition \"tootyfruity\" do\r\n  label \"apple\",      :address => \"192.168.0.1\"\r\n  label \"blueberry\",  :address => \"192.168.0.2\"\r\n  label \"cranberry\",  :address => \"192.168.0.3\"\r\n  label \"eggplant\",   :address => \"192.168.0.4\"\r\n  label \"fennel\",     :address => \"192.168.0.5\"\r\n  label \"grapefruit\", :address => \"192.168.0.6\"\r\n\r\n  rewrite \"forward lots of ports, and don't make SSH public\" do\r\n    protocols \"tcp\"\r\n    ports     80, 8600..8900, 443 => 4443, 2222 => 22\r\n    from      %w(apple blueberry cranberry eggplant fennel grapefruit)\r\n    to        %w(apple blueberry cranberry eggplant fennel grapefruit)\r\n  end\r\nend\r\n```\r\n\r\nThe above example will generate a *lot* of rules, but it illustrates the power\r\nof the DSL.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Ript","tagline":"Ript provides a clean Ruby DSL for describing firewall rules, and implements database migrations-like functionality for applying the rules"}